# CSS Harmony

## Abstract 
This article is has a goal to illustrate the effective way to write CSS in harmony with HTML markup, without loosing declarativity. 

## Typical frontend  project 
Let's create typical for nowadays frontend project using [`npm`](https://www.npmjs.com) tool. We are going to execute create script of a [vite@latest](https://vite.dev) package, using following bash script:

```bash
npm create vite@latest tmp
```

After chanding directory to the freshly created `tmp` one, and executing linux `tree` command we are going to see the following output:

```bash
.
├── README.md
├── eslint.config.js
├── index.html
├── package.json
├── public
│   └── vite.svg
├── src
│   ├── App.css
│   ├── App.tsx
│   ├── assets
│   │   └── react.svg
│   ├── index.css
│   ├── main.tsx
│   └── vite-env.d.ts
├── tsconfig.app.json
├── tsconfig.json
├── tsconfig.node.json
└── vite.config.ts
```

As you can clearly see, `.css` and `.html|.tsx` files are located nearby. 
TSX is a subset of JSX - technology, introduced in [react](https://react.dev) community to merge HTML markup with JavaScript. Such files typically have same name, and located in the same directory, in order to provide some sort of more tighter bounding between markup and styles. 

## The Problem
Let's take a look on some average component written in JSX style, which is similar to HTML: 

```typescript
import React from 'react';

const UserCard = () => {
  return (
    <div className="UserCard">
      <h2>User Card</h2>
      <p>Display user information and logout button here.</p>
      <button className="button">See Profile</button>
    </div>
  );
};

export default UserCard;
```

Let's ignore the JS and React part and focus on a markup part of JSX, which brings us close to HTML. Let's try to imagine how `.css` could be implemented for such a UI component as `UserCard`. Let's take a look in our imaginary `UserCard.css` file: 

```css
.UserCard {
  background-color: #f7f7f7;
  padding: 20px;
  border-radius: 10px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  width: 300px;
}

.UserCard h2 {
  font-size: 18px;
  margin-bottom: 10px;
}

.UserCard p {
  color: #333;
  margin-bottom: 20px;
}

.button {
  background-color: #ccc;
  border: none;
  padding: 10px 20px;
  font-size: 14px;
  cursor: pointer;
}
.button:hover {
  background-color: #bbb;
}
```

As we can see, this css is creating something like a two leaf tree  

```bash 
:root
  |
  |-- .UserCard
  |    |
  |    |-- h2
  |    |-- p
  |-- .button
       |
       |-- :hover
```

But let's take a look on our html again, and determine the HTML structure in file, let's visualize an HTML tree here as well:

```bash
:root
  |
  |-- div.UserCard
       |-- h2
       |-- p
       |
       |-- button.button
```

The trees do not match, but what does it mean for us as for developers? According to documentation of [how browsers work](https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#building_the_dom_tree), we can expect that such a CSS tree, which is in official documentation called `CSSOM tree` would be recursively applied on top of the `DOM tree` which has similar structure as shown in our example above. That means that the alghorythm of traversing the DOM tree, by reaching our `.button` leaf, would search for the corresponding selectors in in our CSS tree to apply additional styles. The more _flat_ structure of our CSS tree would force the algorythm to apply the styles to our `button` element which are living on a different, less deep CSS tree level, than the `button` element is situated. 
By specification CSSOM tree is not depends on DOM tree anyhow, and it should not. Algorythm is fast enough to process huge stylesheets vs huge DOM trees of elements. But from the developer perspective, let's try to analyse, how this algorythm would apply the styles for rendering, and imagine the parallel tree traversing logic, without any optimisations: 

1. Read the first node `.UserCard` 
  1.1 Start looking up for styles in CSS tree, put the cursor on the first CSS tree node. Match!
  1.2 Apply the styles
2. Read the first child node `div.UserCard > h2`.
  2.1 Continue going through the CSS tree and go into the first child `.UserCard > h2` node. Match!
  2.2 Apply the styles
3. Read the second child node `div.UserCard > p`.
  3.1 Continue going through the CSS tree and go into the third child `.UserCard > p`.Match!
  3.2 Apply the styles
4. Read the third child node `div.UserCard > button.button`.
  4.1 Continue going throught the CSS tree. Run out of children on the cursor lvl
  4.2 Go up, to the next node `.button`. Match!
  4.3 Apply the styles

Are you able to see the difference between first three points, and last one? The point 4.2. Seems like not a huge difference in context of the recursion it looks perfectly fine. But what does it change for us? Let's add one more element to our markup:

```typescript
import React from 'react';

const UserCard = () => {
  return (
    <div className="UserCard">
      <h2>User Card</h2>
      <p>Display user information and logout button here.</p>
      <button className="button">See Profile</button>
      <button className="button secondary">Logout</button>
    </div>
  );
};
export default UserCard;
```

What our dead simple algorythm would do with this new `button` element? Let's see: 

5. Read the forth child node `div.UserCard > button.button.secondary`.
  5.1 Start going throught the CSS tree again, put a cursor on a first CSS tree node `.UserCard`. Match!
  5.2 Looking further, go throught the leafs, `.UserCard > h2`, `.UserCard > p`. No full match..
  5.3 Going level up to the second node `button.button`. Match!
  5.4 Apply the styles. 

From this perspective we can see now, that the alghorythm go for a search into a deeper levels of the CSS tree, and return cursor back without getting any results. Of course there are lots of optimisations which would allow the algorythm to skip such a "traps" wherever possible. But what about our understanding of how this styles would apply? Let's add some styles for a button on a level where button is situated in DOM.

```bash
:root
  |
  |-- .UserCard
  |    |
  |    |-- h2
  |    |-- p
  |    |--.button
  |    
  |-- .button
       |
       |-- :hover
```

What now? Can you tell exactly which styles would apply on a particular button by not making your eyeballs do the roundtrip throught the whole `.css` file? 

```css
.UserCard {
  background-color: #f7f7f7;
  padding: 20px;
  border-radius: 10px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  width: 300px;
}

.UserCard h2 {
  font-size: 18px;
  margin-bottom: 10px;
}

.UserCard p {
  color: #666;
  margin-bottom: 20px;
}

.UserCard button.button {
  background-color: #eee;
  font-size: 16px;
}

.button {
  background-color: #ccc;
  border: none;
  padding: 10px 20px;
  font-size: 14px;
  cursor: pointer;
}
.button {
  background-color: #bbb;
}

```

Doesn't it feel like solving and additional puzzle in your mind? Imagine having larger project with bunch of common styles, several layers of components mixed together in a various of ways? Could you predict the styles? 

## The ergonomy
The example above illustrates the problem of ergonomy of an `.css` + `html` code which grows larger same way as project grows. This typical problem could be solved in a various of ways. I know three of them: 

### Naming
Let's create more unique namings for the styles, adding more descriptive words. In such a scenario our  `.button` class would be written in a more specific way according to button role. e.g. `.UserProfileButton`. This is good approach to the extent. When your project is small, the number of components are low, you can easily create specific styles for their essential parts utilizing parts of their names as prefixes. 
This could be an ideal approach for the creative people who are in love with books, with a huge vocabularies in mind. Let's imagine such a css file:

```css
/* Primary Buttons */
.primary-button {
  // ...
}

/* Secondary Buttons */
.secondary-button {
  // ...
}

/* Primary Call-to-Action (CTA) Buttons */
.cta-button {
  // ...
}

/* Secondary CTA Buttons */
.secondary-cta-button {
  // ...
}

/* Social Media Buttons */
.social-button {
  // ...
}

/* Header Buttons */
.header-button {
  // ...
}

/* Footer Buttons */
.footer-button {
  // ...
}
```


